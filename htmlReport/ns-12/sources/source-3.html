


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=GBK"> 
  <title>Coverage Report > UltimateThreadGroupHelper</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">us.abstracta.jmeter.javadsl.core.threadgroups.defaultthreadgroup</a>
</div>

<h1>Coverage Summary for Class: UltimateThreadGroupHelper (us.abstracta.jmeter.javadsl.core.threadgroups.defaultthreadgroup)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">UltimateThreadGroupHelper</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (59/59)
  </span>
</td>
</tr>
  <tr>
    <td class="name">UltimateThreadGroupHelper$CodeBuilder</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    92.9%
  </span>
  <span class="absValue">
    (13/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">UltimateThreadGroupHelper$ThreadsTimeline</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    98.9%
  </span>
  <span class="absValue">
    (87/88)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">UltimateThreadGroupHelper$UltimateThreadSchedule</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (17/17)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    96.2%
  </span>
  <span class="absValue">
    (25/26)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    98.9%
  </span>
  <span class="absValue">
    (176/178)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package us.abstracta.jmeter.javadsl.core.threadgroups.defaultthreadgroup;
&nbsp;
&nbsp;import java.lang.reflect.Method;
&nbsp;import java.time.Duration;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Collections;
&nbsp;import java.util.Comparator;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.LinkedHashMap;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Map.Entry;
&nbsp;import java.util.Stack;
&nbsp;import kg.apc.jmeter.JMeterPluginsUtils;
&nbsp;import kg.apc.jmeter.threads.UltimateThreadGroup;
&nbsp;import kg.apc.jmeter.threads.UltimateThreadGroupGui;
&nbsp;import org.apache.jmeter.control.LoopController;
&nbsp;import org.apache.jmeter.gui.util.PowerTableModel;
&nbsp;import org.apache.jmeter.testelement.property.CollectionProperty;
&nbsp;import org.apache.jmeter.testelement.property.JMeterProperty;
&nbsp;import org.apache.jmeter.threads.AbstractThreadGroup;
&nbsp;import us.abstracta.jmeter.javadsl.codegeneration.MethodCall;
&nbsp;import us.abstracta.jmeter.javadsl.codegeneration.MethodCallBuilder;
&nbsp;import us.abstracta.jmeter.javadsl.codegeneration.MethodCallContext;
&nbsp;import us.abstracta.jmeter.javadsl.codegeneration.MethodParam;
&nbsp;import us.abstracta.jmeter.javadsl.codegeneration.TestElementParamBuilder;
&nbsp;import us.abstracta.jmeter.javadsl.codegeneration.params.DurationParam;
&nbsp;import us.abstracta.jmeter.javadsl.codegeneration.params.IntParam;
&nbsp;import us.abstracta.jmeter.javadsl.core.threadgroups.BaseThreadGroup;
&nbsp;import us.abstracta.jmeter.javadsl.core.threadgroups.DslDefaultThreadGroup;
&nbsp;
<b class="fc">&nbsp;public class UltimateThreadGroupHelper extends BaseThreadGroup&lt;DslDefaultThreadGroup&gt; {</b>
&nbsp;
&nbsp;  private final List&lt;Stage&gt; stages;
&nbsp;
&nbsp;  public UltimateThreadGroupHelper(List&lt;Stage&gt; stages) {
<b class="fc">&nbsp;    super(null, UltimateThreadGroupGui.class, Collections.emptyList());</b>
<b class="fc">&nbsp;    this.stages = stages;</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public AbstractThreadGroup buildThreadGroup() {
<b class="fc">&nbsp;    UltimateThreadGroup ret = new UltimateThreadGroup();</b>
<b class="fc">&nbsp;    PowerTableModel table = buildTableModel();</b>
<b class="fc">&nbsp;    buildUltimateThreadGroupSchedules(stages).forEach(s -&gt; table.addRow(s.buildTableRow()));</b>
<b class="fc">&nbsp;    ret.setData(JMeterPluginsUtils.tableModelRowsToCollectionProperty(table,</b>
&nbsp;        UltimateThreadGroup.DATA_PROPERTY));
<b class="fc">&nbsp;    LoopController loopController = new LoopController();</b>
<b class="fc">&nbsp;    loopController.setLoops(-1);</b>
<b class="fc">&nbsp;    loopController.setContinueForever(true);</b>
<b class="fc">&nbsp;    ret.setSamplerController(loopController);</b>
<b class="fc">&nbsp;    return ret;</b>
&nbsp;  }
&nbsp;
&nbsp;  private static PowerTableModel buildTableModel() {
<b class="fc">&nbsp;    return new PowerTableModel(UltimateThreadGroupGui.columnIdentifiers,</b>
&nbsp;        UltimateThreadGroupGui.columnClasses);
&nbsp;  }
&nbsp;
&nbsp;  private List&lt;UltimateThreadSchedule&gt; buildUltimateThreadGroupSchedules(List&lt;Stage&gt; stages) {
<b class="fc">&nbsp;    List&lt;UltimateThreadSchedule&gt; ret = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;    Duration delay = Duration.ZERO;</b>
<b class="fc">&nbsp;    int threads = 0;</b>
<b class="fc">&nbsp;    Stack&lt;UltimateThreadSchedule&gt; stack = new Stack&lt;&gt;();</b>
<b class="fc">&nbsp;    UltimateThreadSchedule curr = new UltimateThreadSchedule(0, Duration.ZERO, Duration.ZERO,</b>
&nbsp;        Duration.ZERO, Duration.ZERO);
<b class="fc">&nbsp;    for (Stage s : stages) {</b>
<b class="fc">&nbsp;      int stageThreads = (int) s.threadCount();</b>
<b class="fc">&nbsp;      Duration stageDuration = (Duration) s.duration();</b>
<b class="fc">&nbsp;      if (stageThreads == threads) {</b>
<b class="fc">&nbsp;        curr.hold = curr.hold.plus(stageDuration);</b>
<b class="fc">&nbsp;      } else if (stageThreads &gt; threads) {</b>
<b class="fc">&nbsp;        stack.add(curr);</b>
<b class="fc">&nbsp;        curr = new UltimateThreadSchedule(stageThreads - threads, delay, stageDuration,</b>
&nbsp;            Duration.ZERO, Duration.ZERO);
&nbsp;      } else {
<b class="fc">&nbsp;        int diff = threads - stageThreads;</b>
<b class="fc">&nbsp;        Duration shutdown = stageDuration;</b>
<b class="fc">&nbsp;        while (diff &gt; curr.threadCount) {</b>
<b class="fc">&nbsp;          curr.shutdown = interpolateDurationForThreadCountWithRamp(curr.threadCount, diff,</b>
&nbsp;              shutdown);
<b class="fc">&nbsp;          diff -= curr.threadCount;</b>
<b class="fc">&nbsp;          shutdown = shutdown.minus(curr.shutdown);</b>
<b class="fc">&nbsp;          curr = completeCurrentSchedule(curr, ret, stack);</b>
&nbsp;        }
<b class="fc">&nbsp;        if (diff == curr.threadCount) {</b>
<b class="fc">&nbsp;          curr.shutdown = shutdown;</b>
&nbsp;        } else {
<b class="fc">&nbsp;          Duration start = interpolateDurationForThreadCountWithRamp(diff, curr.threadCount,</b>
<b class="fc">&nbsp;              curr.startup);</b>
<b class="fc">&nbsp;          UltimateThreadSchedule last = curr;</b>
<b class="fc">&nbsp;          curr = new UltimateThreadSchedule(diff, curr.delay.plus(curr.startup).minus(start), start,</b>
<b class="fc">&nbsp;              curr.hold, shutdown);</b>
<b class="fc">&nbsp;          last.threadCount -= diff;</b>
<b class="fc">&nbsp;          last.startup = last.startup.minus(start);</b>
<b class="fc">&nbsp;          last.hold = Duration.ZERO;</b>
<b class="fc">&nbsp;          stack.push(last);</b>
&nbsp;        }
<b class="fc">&nbsp;        curr = completeCurrentSchedule(curr, ret, stack);</b>
&nbsp;      }
<b class="fc">&nbsp;      threads = stageThreads;</b>
<b class="fc">&nbsp;      delay = delay.plus(stageDuration);</b>
<b class="fc">&nbsp;    }</b>
<b class="fc">&nbsp;    while (!stack.isEmpty()) {</b>
<b class="fc">&nbsp;      curr = completeCurrentSchedule(curr, ret, stack);</b>
&nbsp;    }
<b class="fc">&nbsp;    ret.sort(Comparator.comparing(r -&gt; r.delay.toMillis()));</b>
<b class="fc">&nbsp;    return ret;</b>
&nbsp;  }
&nbsp;
<b class="fc">&nbsp;  protected static class UltimateThreadSchedule {</b>
&nbsp;
&nbsp;    private int threadCount;
&nbsp;    private final Duration delay;
&nbsp;    private Duration startup;
&nbsp;    private Duration hold;
&nbsp;    private Duration shutdown;
&nbsp;
&nbsp;    public UltimateThreadSchedule(int threadCount, Duration delay, Duration startup,
<b class="fc">&nbsp;        Duration hold, Duration shutdown) {</b>
<b class="fc">&nbsp;      this.threadCount = threadCount;</b>
<b class="fc">&nbsp;      this.delay = delay;</b>
<b class="fc">&nbsp;      this.startup = startup;</b>
<b class="fc">&nbsp;      this.hold = hold;</b>
<b class="fc">&nbsp;      this.shutdown = shutdown;</b>
&nbsp;    }
&nbsp;
&nbsp;    public static UltimateThreadSchedule fromTableRow(Object[] row) {
<b class="fc">&nbsp;      int i = 0;</b>
<b class="fc">&nbsp;      return new UltimateThreadSchedule(Integer.parseInt(stringProp(row[i++])), duration(row[i++]),</b>
<b class="fc">&nbsp;          duration(row[i++]), duration(row[i++]), duration(row[i]));</b>
&nbsp;    }
&nbsp;
&nbsp;    private static Duration duration(Object val) {
<b class="fc">&nbsp;      return Duration.ofSeconds(Long.parseLong(stringProp(val)));</b>
&nbsp;    }
&nbsp;
&nbsp;    private static String stringProp(Object val) {
<b class="fc">&nbsp;      return ((JMeterProperty) val).getStringValue();</b>
&nbsp;    }
&nbsp;
&nbsp;    public Object[] buildTableRow() {
<b class="fc">&nbsp;      return new Object[]{String.valueOf(threadCount),</b>
<b class="fc">&nbsp;          String.valueOf(durationToSeconds(delay)),</b>
<b class="fc">&nbsp;          String.valueOf(durationToSeconds(startup)),</b>
<b class="fc">&nbsp;          String.valueOf(durationToSeconds(hold)),</b>
<b class="fc">&nbsp;          String.valueOf(durationToSeconds(shutdown))};</b>
&nbsp;    }
&nbsp;
&nbsp;  }
&nbsp;
&nbsp;  private static Duration interpolateDurationForThreadCountWithRamp(int threadCount,
&nbsp;      int rampThreads, Duration rampDuration) {
<b class="fc">&nbsp;    return Duration.ofMillis(</b>
<b class="fc">&nbsp;        (long) (rampDuration.toMillis() * ((double) threadCount / rampThreads)));</b>
&nbsp;  }
&nbsp;
&nbsp;  private UltimateThreadSchedule completeCurrentSchedule(UltimateThreadSchedule curr,
&nbsp;      List&lt;UltimateThreadSchedule&gt; ret, Stack&lt;UltimateThreadSchedule&gt; stack) {
<b class="fc">&nbsp;    ret.add(curr);</b>
<b class="fc">&nbsp;    UltimateThreadSchedule last = curr;</b>
<b class="fc">&nbsp;    curr = stack.pop();</b>
<b class="fc">&nbsp;    curr.hold = curr.hold.plus(last.startup).plus(last.hold).plus(last.shutdown);</b>
<b class="fc">&nbsp;    return curr;</b>
&nbsp;  }
&nbsp;
&nbsp;  public static class CodeBuilder extends MethodCallBuilder {
&nbsp;
&nbsp;    public CodeBuilder(List&lt;Method&gt; builderMethods) {
<b class="fc">&nbsp;      super(builderMethods);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean matches(MethodCallContext context) {
<b class="nc">&nbsp;      return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public MethodCall buildMethodCall(MethodCallContext context) {
<b class="fc">&nbsp;      TestElementParamBuilder testElement = new TestElementParamBuilder(context.getTestElement());</b>
<b class="fc">&nbsp;      MethodParam name = testElement.nameParam(&quot;jp@gc - Ultimate Thread Group&quot;);</b>
<b class="fc">&nbsp;      MethodCall ret = buildMethodCall(name);</b>
<b class="fc">&nbsp;      return ThreadsTimeline.fromSchedules(schedulesProp(testElement))</b>
<b class="fc">&nbsp;          .addMethodCallsTo(ret);</b>
&nbsp;    }
&nbsp;
&nbsp;    private List&lt;UltimateThreadSchedule&gt; schedulesProp(TestElementParamBuilder testElement) {
<b class="fc">&nbsp;      JMeterProperty schedulesProp = testElement.prop(UltimateThreadGroup.DATA_PROPERTY);</b>
<b class="fc">&nbsp;      PowerTableModel tableModel = buildTableModel();</b>
<b class="fc">&nbsp;      JMeterPluginsUtils.collectionPropertyToTableModelRows((CollectionProperty) schedulesProp,</b>
&nbsp;          tableModel);
<b class="fc">&nbsp;      List&lt;UltimateThreadSchedule&gt; ret = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;      for (int i = 0; i &lt; tableModel.getRowCount(); i++) {</b>
<b class="fc">&nbsp;        ret.add(UltimateThreadSchedule.fromTableRow(tableModel.getRowData(i)));</b>
&nbsp;      }
<b class="fc">&nbsp;      return ret;</b>
&nbsp;    }
&nbsp;
&nbsp;  }
&nbsp;
<b class="fc">&nbsp;  private static class ThreadsTimeline {</b>
&nbsp;
<b class="fc">&nbsp;    private final Map&lt;Duration, Integer&gt; points = new LinkedHashMap&lt;&gt;();</b>
<b class="fc">&nbsp;    private Duration lastDuration = Duration.ZERO;</b>
&nbsp;    private int lastThreads;
&nbsp;    private double lastSlope;
&nbsp;
<b class="fc">&nbsp;    private ThreadsTimeline() {</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    private ThreadsTimeline(UltimateThreadSchedule s) {</b>
<b class="fc">&nbsp;      Duration duration = Duration.ZERO;</b>
<b class="fc">&nbsp;      if (!s.delay.isZero()) {</b>
<b class="fc">&nbsp;        duration = duration.plus(s.delay);</b>
<b class="fc">&nbsp;        points.put(duration, 0);</b>
&nbsp;      }
<b class="fc">&nbsp;      duration = duration.plus(s.startup);</b>
<b class="fc">&nbsp;      points.put(duration, s.threadCount);</b>
<b class="fc">&nbsp;      if (!s.hold.isZero()) {</b>
<b class="fc">&nbsp;        duration = duration.plus(s.hold);</b>
<b class="fc">&nbsp;        points.put(duration, s.threadCount);</b>
&nbsp;      }
<b class="fc">&nbsp;      duration = duration.plus(s.shutdown);</b>
<b class="fc">&nbsp;      points.put(duration, 0);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static ThreadsTimeline fromSchedules(List&lt;UltimateThreadSchedule&gt; scheds) {
<b class="fc">&nbsp;      ThreadsTimeline ret = new ThreadsTimeline();</b>
<b class="fc">&nbsp;      for (UltimateThreadSchedule s : scheds) {</b>
<b class="fc">&nbsp;        ret = ret.plus(new ThreadsTimeline(s));</b>
<b class="fc">&nbsp;      }</b>
<b class="fc">&nbsp;      return ret;</b>
&nbsp;    }
&nbsp;
&nbsp;    public ThreadsTimeline plus(ThreadsTimeline other) {
<b class="fc">&nbsp;      if (points.isEmpty()) {</b>
<b class="fc">&nbsp;        return other;</b>
&nbsp;      }
<b class="fc">&nbsp;      ThreadsTimeline ret = new ThreadsTimeline();</b>
<b class="fc">&nbsp;      Iterator&lt;Entry&lt;Duration, Integer&gt;&gt; thisIter = this.points.entrySet()</b>
<b class="fc">&nbsp;          .iterator();</b>
<b class="fc">&nbsp;      Iterator&lt;Map.Entry&lt;Duration, Integer&gt;&gt; otherIter = other.points.entrySet()</b>
<b class="fc">&nbsp;          .iterator();</b>
<b class="fc">&nbsp;      Entry&lt;Duration, Integer&gt; thisPoint = thisIter.next();</b>
<b class="fc">&nbsp;      Entry&lt;Duration, Integer&gt; otherPoint = otherIter.next();</b>
<b class="fc">&nbsp;      int prevThisThread = 0;</b>
<b class="fc">&nbsp;      int prevOtherThread = 0;</b>
<b class="fc">&nbsp;      while (thisPoint != null &amp;&amp; otherPoint != null) {</b>
<b class="fc">&nbsp;        int durationOrder = thisPoint.getKey().compareTo(otherPoint.getKey());</b>
<b class="fc">&nbsp;        if (durationOrder == 0) {</b>
<b class="fc">&nbsp;          prevThisThread = thisPoint.getValue();</b>
<b class="fc">&nbsp;          prevOtherThread = otherPoint.getValue();</b>
<b class="fc">&nbsp;          ret.add(thisPoint.getKey(), prevThisThread + prevOtherThread);</b>
<b class="fc">&nbsp;          thisPoint = nextPoint(thisIter);</b>
<b class="fc">&nbsp;          otherPoint = nextPoint(otherIter);</b>
<b class="fc">&nbsp;        } else if (durationOrder &lt; 0) {</b>
<b class="fc">&nbsp;          prevThisThread = thisPoint.getValue();</b>
<b class="fc">&nbsp;          ret.add(thisPoint.getKey(), prevThisThread + prevOtherThread);</b>
<b class="fc">&nbsp;          thisPoint = nextPoint(thisIter);</b>
&nbsp;        } else {
<b class="fc">&nbsp;          prevOtherThread = otherPoint.getValue();</b>
<b class="fc">&nbsp;          ret.add(otherPoint.getKey(), prevThisThread + prevOtherThread);</b>
<b class="fc">&nbsp;          otherPoint = nextPoint(otherIter);</b>
&nbsp;        }
<b class="fc">&nbsp;      }</b>
<b class="fc">&nbsp;      Entry&lt;Duration, Integer&gt; pendingPoint = thisPoint != null ? thisPoint : otherPoint;</b>
&nbsp;      Iterator&lt;Map.Entry&lt;Duration, Integer&gt;&gt; pendingIter =
<b class="fc">&nbsp;          thisPoint != null ? thisIter : otherIter;</b>
<b class="fc">&nbsp;      while (pendingPoint != null) {</b>
<b class="fc">&nbsp;        ret.add(pendingPoint.getKey(), pendingPoint.getValue());</b>
<b class="fc">&nbsp;        pendingPoint = nextPoint(pendingIter);</b>
&nbsp;      }
<b class="fc">&nbsp;      return ret;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void add(Duration duration, int threads) {
<b class="fc">&nbsp;      if (duration.equals(lastDuration) &amp;&amp; threads == lastThreads) {</b>
&nbsp;        return;
&nbsp;      }
&nbsp;      // we calculate slope to identify if we can compact the new point with previous one
&nbsp;      double slope;
<b class="fc">&nbsp;      if (duration.equals(lastDuration)) {</b>
<b class="nc">&nbsp;        slope = threads &gt; lastThreads ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;</b>
&nbsp;      } else {
<b class="fc">&nbsp;        slope = (double) (threads - lastThreads) / duration.minus(lastDuration).getSeconds();</b>
&nbsp;      }
&nbsp;      // using double comparison with threshold to avoid precision issues while comparing slopes
<b class="fc">&nbsp;      if (Math.abs(slope - lastSlope) &lt; 0.01) {</b>
<b class="fc">&nbsp;        points.remove(lastDuration);</b>
&nbsp;      }
<b class="fc">&nbsp;      points.put(duration, threads);</b>
<b class="fc">&nbsp;      lastDuration = duration;</b>
<b class="fc">&nbsp;      lastThreads = threads;</b>
<b class="fc">&nbsp;      lastSlope = slope;</b>
&nbsp;    }
&nbsp;
&nbsp;    private Entry&lt;Duration, Integer&gt; nextPoint(Iterator&lt;Entry&lt;Duration, Integer&gt;&gt; iter) {
<b class="fc">&nbsp;      return iter.hasNext() ? iter.next() : null;</b>
&nbsp;    }
&nbsp;
&nbsp;    private MethodCall addMethodCallsTo(MethodCall methodCall) {
<b class="fc">&nbsp;      int prevThreads = 0;</b>
<b class="fc">&nbsp;      Duration prevDuration = Duration.ZERO;</b>
<b class="fc">&nbsp;      Duration rampDuration = Duration.ZERO;</b>
<b class="fc">&nbsp;      Duration holdDuration = Duration.ZERO;</b>
<b class="fc">&nbsp;      for (Map.Entry&lt;Duration, Integer&gt; point : points.entrySet()) {</b>
<b class="fc">&nbsp;        if (point.getValue() == prevThreads) {</b>
<b class="fc">&nbsp;          holdDuration = holdDuration.plus(point.getKey().minus(prevDuration));</b>
&nbsp;        } else {
<b class="fc">&nbsp;          if (!rampDuration.isZero()) {</b>
<b class="fc">&nbsp;            if (!holdDuration.isZero()) {</b>
<b class="fc">&nbsp;              methodCall.chain(&quot;rampToAndHold&quot;, new IntParam(prevThreads),</b>
&nbsp;                  new DurationParam(rampDuration), new DurationParam(holdDuration));
<b class="fc">&nbsp;              holdDuration = Duration.ZERO;</b>
&nbsp;            } else {
<b class="fc">&nbsp;              chainRampTo(methodCall, prevThreads, rampDuration);</b>
&nbsp;            }
&nbsp;          } else {
<b class="fc">&nbsp;            if (!holdDuration.isZero()) {</b>
<b class="fc">&nbsp;              methodCall.chain(&quot;holdFor&quot;, new DurationParam(holdDuration));</b>
<b class="fc">&nbsp;              holdDuration = Duration.ZERO;</b>
&nbsp;            }
&nbsp;          }
<b class="fc">&nbsp;          rampDuration = point.getKey().minus(prevDuration);</b>
&nbsp;        }
<b class="fc">&nbsp;        prevThreads = point.getValue();</b>
<b class="fc">&nbsp;        prevDuration = point.getKey();</b>
<b class="fc">&nbsp;      }</b>
<b class="fc">&nbsp;      if (!rampDuration.isZero()) {</b>
<b class="fc">&nbsp;        chainRampTo(methodCall, prevThreads, rampDuration);</b>
&nbsp;
&nbsp;      }
<b class="fc">&nbsp;      return methodCall;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void chainRampTo(MethodCall methodCall, int threads, Duration rampDuration) {
<b class="fc">&nbsp;      methodCall.chain(&quot;rampTo&quot;, new IntParam(threads), new DurationParam(rampDuration));</b>
&nbsp;    }
&nbsp;
&nbsp;  }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-03 20:57</div>
</div>
</body>
</html>
