package us.abstracta.jmeter.javadsl.http;

import static us.abstracta.jmeter.javadsl.JmeterDsl.jsr223PreProcessor;

import java.nio.charset.Charset;
import java.util.function.Function;
import org.apache.jmeter.config.Arguments;
import org.apache.jmeter.protocol.http.control.gui.HttpTestSampleGui;
import org.apache.jmeter.protocol.http.sampler.HTTPSamplerProxy;
import org.apache.jmeter.protocol.http.util.HTTPArgument;
import org.apache.jmeter.testelement.TestElement;
import org.apache.jorphan.collections.HashTree;
import org.eclipse.jetty.http.HttpMethod;
import org.eclipse.jetty.http.MimeTypes;
import us.abstracta.jmeter.javadsl.JmeterDsl;
import us.abstracta.jmeter.javadsl.core.BuildTreeContext;
import us.abstracta.jmeter.javadsl.core.preprocessors.DslJsr223PreProcessor.PreProcessorScript;
import us.abstracta.jmeter.javadsl.core.preprocessors.DslJsr223PreProcessor.PreProcessorVars;
import us.abstracta.jmeter.javadsl.core.testelements.DslSampler;

/**
 * Allows to configure a JMeter HTTP sampler to make HTTP requests in a test plan.
 *
 * @since 0.1
 */
public class DslHttpSampler extends DslSampler<DslHttpSampler> {

  private final String url;
  private HttpMethod method = HttpMethod.GET;
  private final HttpHeaders headers = new HttpHeaders();
  private String body;
  private String host;
  private Integer port;
  private String protocol;
  private Charset encoding;
  private boolean followRedirects = true;
  private boolean downloadEmbeddedResources;
  private HttpClientImpl clientImpl;

  public DslHttpSampler(String name, String url) {
    super(buildName(name), HttpTestSampleGui.class);
    this.url = url;
  }

  public DslHttpSampler(String name, Function<PreProcessorVars, String> urlSupplier) {
    super(buildName(name), HttpTestSampleGui.class);
    String variableName = "PRE_PROCESSOR_URL";
    this.url = "${" + variableName + "}";
    children(
        jsr223PreProcessor(s -> s.vars.put(variableName, urlSupplier.apply(s))
        ));
  }

  private static String buildName(String name) {
    return name != null ? name : "HTTP Request";
  }

  /**
   * Specifies that the sampler should send an HTTP POST to defined URL.
   *
   * @param body        to include in HTTP POST request body.
   * @param contentType to be sent as Content-Type header in HTTP POST request.
   * @return the altered sampler to allow for fluent API usage.
   */
  public DslHttpSampler post(String body, MimeTypes.Type contentType) {
    return method(HttpMethod.POST)
        .contentType(contentType)
        .body(body);
  }

  /**
   * Same as {@link #post(String, MimeTypes.Type)} but allowing to use a dynamically calculated
   * body.
   * <p>
   * This method is just an abstraction that uses a JMeter variable as HTTP request body and
   * calculates the variable with a jsr223PreProcessor.
   * <p>
   * <b>WARNING:</b> As this method internally uses
   * {@link JmeterDsl#jsr223PreProcessor(PreProcessorScript)}, same limitations and considerations
   * apply. Check its documentation. To avoid such limitations you may use {@link #post(String,
   * MimeTypes.Type)} with a JMeter variable instead, and dynamically set the variable with {@link
   * JmeterDsl#jsr223PreProcessor(String)}.
   *
   * @param bodySupplier function to calculate the body on each request.
   * @param contentType  to be sent as Content-Type header in HTTP POST request.
   * @return the altered sampler to allow for fluent API usage.
   * @see #body(Function)
   * @since 0.10
   */
  public DslHttpSampler post(Function<PreProcessorVars, String> bodySupplier,
      MimeTypes.Type contentType) {
    return method(HttpMethod.POST)
        .contentType(contentType)
        .body(bodySupplier);
  }

  /**
   * Specifies the HTTP method to be used in the HTTP request generated by the sampler.
   *
   * @param method is the HTTP method to be used by the sampler.
   * @return the altered sampler to allow for fluent API usage.
   */
  public DslHttpSampler method(HttpMethod method) {
    this.method = method;
    return this;
  }

  /**
   * Specifies an HTTP header to be sent by the sampler.
   * <p>
   * To specify multiple headers just invoke this method several times with the different header
   * names and values.
   *
   * @param name  of the HTTP header.
   * @param value of the HTTP header.
   * @return the altered sampler to allow for fluent API usage.
   */
  public DslHttpSampler header(String name, String value) {
    headers.header(name, value);
    return this;
  }

  /**
   * Same as {@link #header(String, String)} but allows using dynamically calculated HTTP header
   * value.
   * <p>
   * This method is just an abstraction that uses a JMeter variable as HTTP header value and
   * calculates the variable with a jsr223PreProcessor.
   * <p>
   * <b>WARNING:</b> As this method internally uses
   * {@link JmeterDsl#jsr223PreProcessor(PreProcessorScript)}, same limitations and considerations
   * apply. Check its documentation. To avoid such limitations you may use {@link #header(String,
   * String)} with a JMeter variable instead, and dynamically set the variable with {@link
   * JmeterDsl#jsr223PreProcessor(String)}.
   *
   * @param name          of the HTTP header.
   * @param valueSupplier builds the header value.
   * @return the altered sampler to allow for fluent API usage.
   * @since 0.10
   */
  public DslHttpSampler header(String name, Function<PreProcessorVars, String> valueSupplier) {
    String variableNamePrefix = "PRE_PROCESSOR_HEADER~";
    headers.header(name, "${" + variableNamePrefix + name + "}");
    return children(
        jsr223PreProcessor(s -> s.vars.put(variableNamePrefix + name, valueSupplier.apply(s)))
    );
  }

  /**
   * Allows to easily specify the Content-Type HTTP header to be used by the sampler.
   *
   * @param contentType value to send as Content-Type header.
   * @return the altered sampler to allow for fluent API usage.
   */
  public DslHttpSampler contentType(MimeTypes.Type contentType) {
    headers.contentType(contentType);
    return this;
  }

  /**
   * Specifies the body to be sent in the HTTP request generated by the sampler.
   *
   * @param body to be used as in the body of the HTTP request.
   * @return the altered sampler to allow for fluent API usage.
   */
  public DslHttpSampler body(String body) {
    this.body = body;
    return this;
  }

  /**
   * Same as {@link #body(String)} but allows using dynamically calculated HTTP request body.
   * <p>
   * This method is just an abstraction that uses a JMeter variable as HTTP request body and
   * calculates the variable with a jsr223PreProcessor.
   * <p>
   * <b>WARNING:</b> As this method internally uses
   * {@link JmeterDsl#jsr223PreProcessor(PreProcessorScript)}, same limitations and considerations
   * apply. Check its documentation.  To avoid such limitations you may use {@link #body(String)}
   * with a JMeter variable instead, and dynamically set the variable with {@link
   * JmeterDsl#jsr223PreProcessor(String)}.
   *
   * @param bodySupplier function to calculate the body on each request.
   * @return the altered sampler to allow for fluent API usage.
   * @since 0.10
   */
  public DslHttpSampler body(Function<PreProcessorVars, String> bodySupplier) {
    String variableName = "PRE_PROCESSOR_REQUEST_BODY";
    this.body = "${" + variableName + "}";
    return children(
        jsr223PreProcessor(s -> s.vars.put(variableName, bodySupplier.apply(s))));
  }

  /**
   * Specifies the charset to be used to encode URLs and request contents.
   *
   * @param encoding contains the charset to be used.
   * @return the altered sampler to allow for fluent API usage.
   * @since 0.39
   */
  public DslHttpSampler encoding(Charset encoding) {
    this.encoding = encoding;
    return this;
  }

  /**
   * Specifies the server host (domain) to be used in the HTTP request generated by the sampler.
   *
   * @param host contains server name without method (no http/https) and path.
   * @return the altered sampler to allow for fluent API usage.
   * @since 0.42
   */
  public DslHttpSampler host(String host) {
    this.host = host;
    return this;
  }

  /**
   * Specifies the HTTP Sampler port to be used in the HTTP request generated by the sampler.
   *
   * @param port contains port value to be used.
   * @return the altered sampler to allow for fluent API usage.
   * @since 0.42
   */
  public DslHttpSampler port(Integer port) {
    this.port = port;
    return this;
  }

  /**
   * Specifies the HTTP Sampler protocol to be used in the HTTP request generated by the sampler.
   * For example "http" or "https"
   *
   * @param protocol contains protocol value to be used.
   * @return the altered sampler to allow for fluent API usage.
   * @since 0.42
   */
  public DslHttpSampler protocol(String protocol) {
    this.protocol = protocol;
    return this;
  }

  /**
   * Allows enabling/disabling automatic request for redirects.
   * <p>
   * When a response is a redirection response (3xx status code with a Location header), JMeter
   * automatically generates a new request to the redirected destination registering the redirect
   * request as a sub sample. This method allows enabling/disabling such behavior.
   *
   * @param followRedirects sets either to enable or disable automatic redirects. By default,
   *                        redirects are automatically followed.
   * @return the altered sampler to allow for fluent API usage.
   * @since 0.21
   */
  public DslHttpSampler followRedirects(boolean followRedirects) {
    this.followRedirects = followRedirects;
    return this;
  }

  /**
   * Allows enabling automatic download of HTML embedded resources (images, iframes, etc).
   * <p>
   * When enabled JMeter will automatically parse HTMLs and download any found embedded resources
   * adding their information as sub samples of the original request.
   * <p>
   * Additionally, and in contrast to JMeter, this will download embedded resources in parallel by
   * default (with up to 6 parallel downloads). The DSL enables this behavior by default since it is
   * the most common way to use it to properly emulate browsers behavior.
   * <p>
   * Check <a href="https://jmeter.apache.org/usermanual/component_reference.html#HTTP_Request">JMeter
   * HTTP Request documentation</a> for additional details on embedded resources download.
   *
   * @return the altered sampler to allow for fluent API usage.
   * @since 0.24
   */
  public DslHttpSampler downloadEmbeddedResources() {
    this.downloadEmbeddedResources = true;
    return this;
  }

  /**
   * Allows specifying the HTTP client implementation to use for this particular sampler.
   * <p>
   * Changing the default implementation ({@link DslHttpSampler.HttpClientImpl#HTTP_CLIENT}) to
   * {@link DslHttpSampler.HttpClientImpl#JAVA} may improve performance in some scenarios
   * (connection time, memory, cpu usage). But, Java implementation has its own limitations, check
   * <a href="https://jmeter.apache.org/usermanual/component_reference.html#HTTP_Request">JMeter
   * documentation</a> for more details.
   *
   * @param clientImpl the HTTP client implementation to use. If none is specified, then {@link
   *                   DslHttpSampler.HttpClientImpl#HTTP_CLIENT} is used.
   * @return the altered sampler to allow for fluent API usage.
   * @since 0.39
   */
  public DslHttpSampler clientImpl(HttpClientImpl clientImpl) {
    this.clientImpl = clientImpl;
    return this;
  }

  @Override
  public TestElement buildTestElement() {
    HTTPSamplerProxy ret = new HTTPSamplerProxy();
    // this might be null if the values are set by defaults element
    if (host != null) {
      ret.setDomain(host);
    }
    if (port != null) {
      ret.setPort(port);
    }
    if (protocol != null) {
      ret.setProtocol(protocol);
    }
    if (url != null) {
      ret.setPath(url);
    }
    ret.setMethod(method.name());
    ret.setArguments(buildArguments());
    if (encoding != null) {
      ret.setContentEncoding(encoding.toString());
    }
    ret.setFollowRedirects(followRedirects);
    ret.setUseKeepAlive(true);
    if (downloadEmbeddedResources) {
      ret.setImageParser(true);
      ret.setConcurrentDwn(true);
    }
    if (clientImpl != null) {
      ret.setImplementation(clientImpl.propertyValue);
    }
    return ret;
  }

  private Arguments buildArguments() {
    Arguments args = new Arguments();
    if (body != null) {
      HTTPArgument arg = new HTTPArgument("", body, false);
      arg.setAlwaysEncoded(false);
      args.addArgument(arg);
    }
    return args;
  }

  @Override
  public HashTree buildTreeUnder(HashTree parent, BuildTreeContext context) {
    HashTree ret = super.buildTreeUnder(parent, context);
    if (!headers.isEmpty()) {
      headers.buildTreeUnder(ret, context);
    }
    new DslCookieManager().buildTreeUnder(null, context);
    new DslCacheManager().buildTreeUnder(null, context);
    return ret;
  }

  /**
   * Specifies an HTTP client implementation to be used by HTTP samplers.
   */
  public enum HttpClientImpl {
    /**
     * Specifies to use the Java implementation.
     */
    JAVA("Java"),
    /**
     * Specifies to use the Apache HttpClient implementation. This is the default one and usually
     * the preferred one.
     */
    HTTP_CLIENT("HttpClient4");

    public final String propertyValue;

    HttpClientImpl(String propertyValue) {
      this.propertyValue = propertyValue;
    }

  }

}
