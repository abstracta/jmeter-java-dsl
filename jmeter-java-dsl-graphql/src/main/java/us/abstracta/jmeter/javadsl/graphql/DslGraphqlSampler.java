package us.abstracta.jmeter.javadsl.graphql;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import java.lang.reflect.Method;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Spliterator;
import java.util.Spliterators;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;
import org.apache.http.entity.ContentType;
import org.apache.jmeter.config.Arguments;
import org.apache.jmeter.protocol.http.config.GraphQLRequestParams;
import org.apache.jmeter.protocol.http.config.gui.GraphQLUrlConfigGui;
import org.apache.jmeter.protocol.http.control.HeaderManager;
import org.apache.jmeter.protocol.http.control.gui.GraphQLHTTPSamplerGui;
import org.apache.jmeter.protocol.http.sampler.HTTPSamplerBase;
import org.apache.jmeter.protocol.http.sampler.HTTPSamplerProxy;
import org.apache.jmeter.protocol.http.util.GraphQLRequestParamUtils;
import org.apache.jmeter.protocol.http.util.HTTPArgument;
import org.apache.jmeter.protocol.http.util.HTTPConstants;
import us.abstracta.jmeter.javadsl.codegeneration.MethodCall;
import us.abstracta.jmeter.javadsl.codegeneration.MethodCallContext;
import us.abstracta.jmeter.javadsl.codegeneration.MethodParam;
import us.abstracta.jmeter.javadsl.codegeneration.MethodParam.StringParam;
import us.abstracta.jmeter.javadsl.codegeneration.TestElementParamBuilder;
import us.abstracta.jmeter.javadsl.http.DslBaseHttpSampler;

/**
 * Allows configuring a GraphQL HTTP Sampler which significantly eases creating GraphQL requests
 * compared to httpSampler.
 * <p>
 * This sampler is based on HTTP Sampler, so all configurations affecting http sampler (headers,
 * cookies, cache, system properties, etc) affect this sampler.
 *
 * @since 0.52
 */
public class DslGraphqlSampler extends DslBaseHttpSampler<DslGraphqlSampler> {

  private static final String DEFAULT_NAME = "GraphQL HTTP Request";
  private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();
  private final String query;
  private String operationName;
  private final Map<String, Object> variables = new LinkedHashMap<>();
  private String varsJson;

  public DslGraphqlSampler(String name, String url, String query) {
    super(name != null ? name : DEFAULT_NAME, url, GraphQLHTTPSamplerGui.class);
    this.query = query;
    headers.contentType(ContentType.APPLICATION_JSON);
  }

  /**
   * Builds a GraphQL HTTP Request sampler to invoke GraphQL operations.
   *
   * @param url specifies URL where the GraphQL service is attending requests.
   * @return the GraphQL HTTP Request sampler instance which can be used to define additional
   * settings like operation name, variables, headers, pre &amp; post processors, etc.
   * @see DslGraphqlSampler
   */
  public static DslGraphqlSampler graphqlSampler(String url, String query) {
    return graphqlSampler(null, url, query);
  }

  /**
   * Same as {@link #graphqlSampler(String, String)} but allowing to set a name to the GraphQL HTTP
   * Request sampler.
   * <p>
   * Setting a proper name allows to easily identify the requests generated by this sampler and
   * check its particular statistics.
   *
   * @see #graphqlSampler(String, String)
   */
  public static DslGraphqlSampler graphqlSampler(String name, String url, String query) {
    return new DslGraphqlSampler(name, url, query);
  }

  /**
   * Specifies the GraphQL operation name to send in the request.
   *
   * <a href="https://graphql.org/learn/queries/#operation-name">Here</a> you can find additional
   * information about operation name purposes.
   *
   * @param operationName is the name to send in the GraphQL request.
   * @return the sampler instance for further configuration or usage.
   */
  public DslGraphqlSampler operationName(String operationName) {
    this.operationName = operationName;
    return this;
  }

  /**
   * Specifies a GraphQL variable to send in the request.
   *
   * <a href="https://graphql.org/learn/queries/#variablese">Here</a> you can find additional
   * information about variables purposes.
   *
   * @param name  specifies the name of the variable.
   * @param value specifies the value associated to the variable. This value is serialized into
   *              json, so for non-primitive values (int, long, boolean, float, double, string,
   *              etc.) make sure they can be properly serialized by jackson library or use {@link
   *              #variables(String)} method instead.
   * @return the sampler instance for further configuration or usage.
   * @throws IllegalArgumentException when provided value object can't be serialized by jackson.
   */
  public DslGraphqlSampler variable(String name, Object value) {
    checkValueSerialization(value);
    this.variables.put(name, value);
    return this;
  }

  private void checkValueSerialization(Object value) {
    try {
      OBJECT_MAPPER.writeValueAsString(value);
    } catch (JsonProcessingException e) {
      throw new IllegalArgumentException("Could not serialize a given GraphQL variable", e);
    }
  }

  /**
   * Allows specifying variables in a string in JSON format as JMeter sampler does.
   * <p>
   * In general prefer using {@link #variable(String, Object)} instead, which is simpler, and avoids
   * potential format issues. Use this method in corner cases when {@link #variable(String, Object)}
   * is a limiting factor.
   *
   * @param variables specifies all variables to be sent in GraphQL request in JSON Object format.
   * @return the sampler instance for further configuration or usage.
   * @see #variable(String, Object)
   */
  public DslGraphqlSampler variables(String variables) {
    this.varsJson = variables;
    return this;
  }

  @Override
  public HTTPSamplerProxy configureHttpTestElement(HTTPSamplerProxy elem) {
    String varsJson = buildVariablesJson();
    elem.setMethod(HTTPConstants.POST);
    elem.setProperty(GraphQLUrlConfigGui.OPERATION_NAME, operationName);
    elem.setProperty(GraphQLUrlConfigGui.QUERY, query);
    elem.setProperty(GraphQLUrlConfigGui.VARIABLES, varsJson);
    elem.setProperty(HTTPSamplerBase.POST_BODY_RAW, false);
    elem.setArguments(buildArguments(varsJson));
    return elem;

  }

  private String buildVariablesJson() {
    if (varsJson != null) {
      return varsJson;
    } else if (variables.isEmpty()) {
      return "";
    } else {
      try {
        return OBJECT_MAPPER.writeValueAsString(variables);
      } catch (JsonProcessingException e) {
        // this should never happen due to checks in variable setting method
        throw new RuntimeException(e);
      }
    }
  }

  private Arguments buildArguments(String jsonVariables) {
    Arguments args = new Arguments();
    String body = GraphQLRequestParamUtils.toPostBodyString(
        new GraphQLRequestParams(operationName, query, jsonVariables));
    HTTPArgument arg = new HTTPArgument("", body, false);
    arg.setAlwaysEncoded(false);
    args.addArgument(arg);
    return args;
  }

  public static class CodeBuilder extends BaseHttpSamplerCodeBuilder {

    public CodeBuilder(List<Method> builderMethods) {
      super(DEFAULT_NAME, GraphQLHTTPSamplerGui.class, builderMethods);
    }

    @Override
    protected MethodCall buildBaseHttpMethodCall(StringParam name, StringParam url,
        TestElementParamBuilder paramBuilder) {
      return buildMethodCall(name, url, paramBuilder.stringParam(GraphQLUrlConfigGui.QUERY));
    }

    @Override
    protected void buildRequestCall(MethodCall ret, HTTPSamplerProxy testElem,
        MethodCallContext buildContext) {
      TestElementParamBuilder paramBuilder = new TestElementParamBuilder(testElem);
      ret.chain("operationName",
          paramBuilder.stringParam(GraphQLUrlConfigGui.OPERATION_NAME));
      StringParam vars = paramBuilder.stringParam(GraphQLUrlConfigGui.VARIABLES);
      if (!vars.isDefault()) {
        try {
          JsonNode varsNode = OBJECT_MAPPER.readValue(vars.getValue(), JsonNode.class);
          boolean simpleVars = iterator2Stream(varsNode.fields())
              .allMatch(v -> v.getValue().isValueNode());
          if (!varsNode.isObject() || !simpleVars) {
            chainRawVariables(ret, vars);
            return;
          }
          iterator2Stream(varsNode.fields())
              .forEach(var -> ret.chain("variable",
                  new StringParam(var.getKey()), new JsonValueParam(var.getValue())));
        } catch (JsonProcessingException e) {
          chainRawVariables(ret, vars);
        }
      }
      setHeaders(ret, buildContext);
    }

    private void setHeaders(MethodCall ret, MethodCallContext buildContext) {
      MethodCallContext headers = buildContext.removeChild(HeaderManager.class);
      String contentType = removeContentTypeHeader(headers);
      if (!ContentType.APPLICATION_JSON.toString().equals(contentType)) {
        chainContentType(ret, contentType);
      }
      chainHeaders(ret, headers);
    }

    private void chainRawVariables(MethodCall ret, StringParam vars) {
      ret.chain("variables", vars);
    }

    private <T> Stream<T> iterator2Stream(Iterator<T> iterator) {
      return StreamSupport.stream(
          Spliterators.spliteratorUnknownSize(iterator, Spliterator.ORDERED), false);
    }

    @Override
    protected void setAdditionalOptions(MethodCall ret, TestElementParamBuilder paramBuilder) {
    }

    private static class JsonValueParam extends MethodParam<Object> {

      public JsonValueParam(JsonNode value) {
        super(Object.class, value, null);
      }

      @Override
      protected String buildCode(String indent) {
        JsonNode node = (JsonNode) value;
        return node.isTextual() ? new StringParam(node.textValue()).buildCode("") : node.asText();
      }

    }

  }

}
