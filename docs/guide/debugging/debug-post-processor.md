### Debug info during test plan execution

Another option that allows collecting debugging information during a test plan execution without affecting test plan execution (doesn't stop the test plan on each breakpoint as IDE debugger does, which will affect test plan collected metrics) and allows analyzing information after test plan execution, is using `debugPostProcessor` which adds a sub result to sampler results including debug information.

Here is an example that collects JMeter variables that can be reviewed with included `resultsTreeVisualizer`:

```java
import static us.abstracta.jmeter.javadsl.JmeterDsl.*;

import java.io.IOException;
import org.junit.jupiter.api.Test;

public class PerformanceTest {

  @Test
  public void testPerformance() throws IOException {
    String userIdVarName = "USER_ID";
    String usersPath = "/users";
    testPlan(
        httpDefaults().url("http://my.service"),
        threadGroup(1, 1,
            httpSampler(usersPath)
                .children(
                    jsonExtractor(userIdVarName, "[].id"),
                    debugPostProcessor()
                ),
            httpSampler(usersPath + "/${" + userIdVarName + "}")
        ),
        resultsTreeVisualizer()
    ).run();
  }

}
```

This approach is particularly helpful when debugging extractors, allowing you to see what JMeter variables were or were not generated by previous extractors.

In general, prefer using [Post processor with IDE debugger breakpoint](./post-processor-debugging#post-processor-breakpoints) in the initial stages of test plan development, testing with just 1 thread in thread groups, and using this later approach when trying to debug issues that are reproducible only in multiple threads executions or in a particular environment that requires offline analysis (analyze collected information after test plan execution).

::: tip
Use this element in combination with `resultsTreeVisualizer` to review live executions, or use `jtlWriter` with `withAllFields()` or `saveAsXml(true)` and `saveResponseData(true)` to generate a jtl file for later analysis.
:::

::: tip
By default, `debugPostProcessor` will only include JMeter variables in generated sub sampler, which covers the most used case and keeps memory and disk usage low. `debugPostProcessor` includes additional methods that allow including other information like sampler properties, JMeter properties, and system properties. Check [DslDebugPostProcessor](/jmeter-java-dsl/src/main/java/us/abstracta/jmeter/javadsl/core/postprocessors/DslDebugPostProcessor.java) for more details.
:::
