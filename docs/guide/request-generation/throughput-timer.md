### Control throughput

To achieve a specific constant throughput for specific samplers or section of a test plan, you can use `throughputTimer`, which uses JMeter `ConstantThroughputTimer`.

Here is an example for generating a maximum of 120 samples per minute:

```java
import static org.assertj.core.api.Assertions.assertThat;
import static us.abstracta.jmeter.javadsl.JmeterDsl.*;

import java.time.Duration;
import org.junit.jupiter.api.Test;
import us.abstracta.jmeter.javadsl.core.TestPlanStats;

public class PerformanceTest {

  @Test
  public void testPerformance() throws Exception {
    TestPlanStats stats = testPlan(
        threadGroup(10, Duration.ofSeconds(10),
            throughputTimer(120),
            httpSampler("http://my.service")
        ) 
    ).run();
  }

}
```

::: tip
By default, `throughtputTimer` will control throughput among active threads. If you want to control throughput per thread, i.e. each thread generating the specified throughput, which means that `totalThoughput = configuredThroughput * numberOfThreads`, you can use `perThread()` method.
:::

::: tip
The placement (scope) of the `throughputTimer` will determine its behaviour. E.g. if you place the timer inside an `ifController`, it will only control the execution throughput only for elements inside the `ifController`, or if you place it inside a `threadGroup` other thread groups execution will be directly not affected (nor they would directly affect this timer execution).  
:::

::: tip
The timer uses by default even distribution of throughput among the active threads. This means that if you have 10 threads and specify 10 tpm, then each thread will try to execute at 1tpm, not adjusting each thread tpm if some other thread was far from achieving the configured tpm. If you want more precise throughput control, you can use `.calculation()` method, for example, with `THREAD_GROUP_ACCURATE`, but doing so, may lead to unexpected behavior when using multiple timers in same thread group.

Check [DslThroughputTimer](/jmeter-java-dsl/src/main/java/us/abstracta/jmeter/javadsl/core/timers/DslThroughputTimer.java) for more details.
:::

::: warning
`throughputTimer` works by pausing requests to achieve a constant throughput, so the response times and number of threads must be sufficient to achieve the target throughput. You can think of this timer as a way to limit the maximum throughput, but it does have no way to generate more load if response times are high and threads are not enough. To automatically adjust threads when response times are high you can use `rpsThreadGroup` as described [here](../thread-groups/rps-thread-group#throughput-based-thread-group).
:::

::: warning
On first invocation of `throughputTimer` on each thread, no delay will be generated by the timer, which may lead to initially higher throughput than expected.

For example, in previously provided example, 10 requests (1 for each thread) will run without "throughput control", which means you will get 10 requests at once, and after that, you will get 1 request per second (as expected).
:::
